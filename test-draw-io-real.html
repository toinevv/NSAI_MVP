<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draw.io Real Test - NewSystem.AI</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .metrics {
            background: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background: #45a049;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        .success {
            color: green;
            font-weight: bold;
        }
        #screenshot-area {
            border: 2px dashed #999;
            padding: 20px;
            margin: 20px 0;
            min-height: 200px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>🔬 Draw.io Export REAL Testing</h1>
    
    <div class="test-section">
        <h2>Test 1: Simple 8-Step Workflow</h2>
        <button onclick="testSimpleWorkflow()">Generate & Open in Draw.io</button>
        <div id="simple-metrics" class="metrics"></div>
    </div>

    <div class="test-section">
        <h2>Test 2: Complex 30-Step Workflow</h2>
        <button onclick="testComplexWorkflow()">Generate & Open in Draw.io</button>
        <div id="complex-metrics" class="metrics"></div>
    </div>

    <div class="test-section">
        <h2>Test 3: Massive 100-Step Workflow</h2>
        <button onclick="testMassiveWorkflow()">Generate & Open in Draw.io</button>
        <div id="massive-metrics" class="metrics"></div>
    </div>

    <div class="test-section">
        <h2>Layout Testing</h2>
        <button onclick="testLayoutScaling()">Test Layout at Different Sizes</button>
        <div id="layout-metrics" class="metrics"></div>
    </div>

    <div id="screenshot-area">
        <h3>📸 Screenshot Instructions</h3>
        <p>After opening in Draw.io:</p>
        <ol>
            <li>Take screenshot with Cmd+Shift+4 (Mac) or PrintScreen (Windows)</li>
            <li>Save as "drawio-proof-[workflow-size].png"</li>
            <li>Note visual quality issues</li>
        </ol>
    </div>

    <script>
        // Copy the actual DrawioGenerator implementation
        class DrawioGenerator {
            generateXML(workflowSteps, title) {
                const startTotal = performance.now();
                
                const startNodes = performance.now();
                const nodes = this.createNodes(workflowSteps);
                const nodesTime = performance.now() - startNodes;
                
                const startEdges = performance.now();
                const edges = this.createEdges(workflowSteps);
                const edgesTime = performance.now() - startEdges;
                
                const titleNode = title ? this.createTitleNode(title) : '';
                
                const startWrap = performance.now();
                const xml = this.wrapInMxGraphModel(titleNode + nodes + edges);
                const wrapTime = performance.now() - startWrap;
                
                const totalTime = performance.now() - startTotal;
                
                // Return both XML and timing
                return {
                    xml,
                    timing: {
                        nodes: nodesTime,
                        edges: edgesTime,
                        wrap: wrapTime,
                        total: totalTime
                    }
                };
            }

            createNodes(steps) {
                const layout = this.calculateSmartLayout(steps);
                return steps.map((step, index) => {
                    const stepId = `step${index + 1}`;
                    const position = layout.positions[index];
                    const lines = this.createProfessionalLabel(step);
                    const label = lines.join('&#xa;');
                    const style = this.getProfessionalStyle(step);
                    
                    return `
    <mxCell id="${stepId}" value="${this.escapeXML(label)}" 
           style="${style}" 
           vertex="1" parent="1">
      <mxGeometry x="${position.x}" y="${position.y}" width="${position.width}" height="${position.height}" as="geometry"/>
    </mxCell>`;
                }).join('');
            }

            calculateSmartLayout(steps) {
                const positions = [];
                const baseWidth = 180;
                const baseHeight = 100;
                const horizontalSpacing = 250;
                const verticalSpacing = 150;
                const startX = 50;
                const startY = 100;
                
                let currentX = startX;
                let currentY = startY;
                let maxY = startY;
                
                // DYNAMIC steps per row based on workflow size
                let maxStepsPerRow;
                if (steps.length <= 10) {
                    maxStepsPerRow = 4; // Compact for small workflows
                } else if (steps.length <= 30) {
                    maxStepsPerRow = 6; // Medium density
                } else {
                    maxStepsPerRow = 8; // Higher density for large workflows
                }
                
                const layoutInfo = {
                    totalSteps: steps.length,
                    stepsPerRow: maxStepsPerRow,
                    estimatedRows: Math.ceil(steps.length / maxStepsPerRow)
                };
                
                steps.forEach((step, index) => {
                    const contentLength = (step.action?.length || 0) + (step.application?.length || 0);
                    const width = Math.max(baseWidth, Math.min(280, baseWidth + (contentLength * 1.5)));
                    const lines = this.createProfessionalLabel(step);
                    const height = Math.max(baseHeight, baseHeight + ((lines.length - 3) * 18));
                    
                    if (index > 0 && index % maxStepsPerRow === 0) {
                        currentX = startX;
                        currentY = maxY + verticalSpacing;
                    }
                    
                    positions.push({ x: currentX, y: currentY, width: width, height: height });
                    currentX += width + horizontalSpacing;
                    maxY = Math.max(maxY, currentY + height);
                });
                
                return {
                    positions,
                    canvasWidth: Math.max(1200, currentX + 200),
                    canvasHeight: maxY + 200,
                    layoutInfo
                };
            }

            createProfessionalLabel(step) {
                const lines = [];
                if (step.action) lines.push(step.action);
                if (step.application) lines.push(`📱 ${step.application}`);
                if (step.time_formatted) lines.push(step.time_formatted);
                if (step.purpose && step.purpose.length < 60) lines.push(`💡 ${step.purpose}`);
                if (step.visible_in_frames?.length > 0) lines.push(`📊 ${step.visible_in_frames.length} frames`);
                return lines;
            }

            getProfessionalStyle(step) {
                const baseStyle = 'rounded=1;whiteSpace=wrap;html=1;fontFamily=Arial;fontSize=11;spacing=4;';
                const fillColor = this.getNodeColor(step.application);
                const strokeColor = this.getStrokeColor(fillColor);
                return `${baseStyle}fillColor=${fillColor};strokeColor=${strokeColor};strokeWidth=2;shadow=1;glass=0;`;
            }

            getNodeColor(application) {
                if (!application) return '#e1d5e7';
                const app = application.toLowerCase();
                if (app.includes('mail') || app.includes('outlook')) return '#fff2cc';
                if (app.includes('excel') || app.includes('sheets')) return '#d5e8d4';
                if (app.includes('chrome') || app.includes('browser') || app.includes('wms')) return '#dae8fc';
                if (app.includes('database') || app.includes('erp')) return '#f8cecc';
                return '#e1d5e7';
            }

            getStrokeColor(fillColor) {
                const strokeMap = {
                    '#fff2cc': '#d6b656', 
                    '#d5e8d4': '#82b366', 
                    '#dae8fc': '#6c8ebf',
                    '#f8cecc': '#b85450', 
                    '#e1d5e7': '#9673a6'
                };
                return strokeMap[fillColor] || '#666666';
            }

            createEdges(steps) {
                if (steps.length <= 1) return '';
                const edges = [];
                steps.slice(0, -1).forEach((step, index) => {
                    const edgeId = `edge${index + 1}`;
                    const sourceId = `step${index + 1}`;
                    const targetId = `step${index + 2}`;
                    const edgeStyle = this.getEdgeStyle(step, steps[index + 1]);
                    
                    edges.push(`
    <mxCell id="${edgeId}" style="${edgeStyle}" 
           source="${sourceId}" target="${targetId}" edge="1" parent="1">
      <mxGeometry relative="1" as="geometry"/>
    </mxCell>`);
                });
                return edges.join('');
            }

            getEdgeStyle(fromStep, toStep) {
                const baseStyle = 'edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;';
                if (fromStep.application === toStep.application) {
                    return `${baseStyle}strokeColor=#82b366;strokeWidth=2;dashed=1;dashPattern=5 5;`;
                } else {
                    return `${baseStyle}strokeColor=#666666;strokeWidth=2;endArrow=classic;endFill=1;`;
                }
            }

            createTitleNode(title) {
                return `
    <mxCell id="title" value="${this.escapeXML(title)}" 
           style="text;html=1;align=center;verticalAlign=middle;fontFamily=Arial;fontSize=14;fontStyle=1;fillColor=#f8f9fa;strokeColor=#dee2e6;" 
           vertex="1" parent="1">
      <mxGeometry x="40" y="10" width="400" height="30" as="geometry"/>
    </mxCell>`;
            }

            wrapInMxGraphModel(content) {
                return `<?xml version="1.0" encoding="UTF-8"?>
<mxfile host="app.diagrams.net">
  <diagram id="workflow" name="NewSystem.AI Workflow Analysis">
    <mxGraphModel dx="2400" dy="1600" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1600" pageHeight="1200">
      <root>
        <mxCell id="0"/>
        <mxCell id="1" parent="0"/>${content}
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>`;
            }

            escapeXML(text) {
                if (!text) return '';
                return text.toString()
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }
        }

        // Test functions
        const generator = new DrawioGenerator();

        function generateWorkflow(size) {
            const apps = ['Microsoft Outlook', 'Chrome Browser (WMS)', 'Excel', 'SAP System', 'Teams'];
            const actions = ['Open', 'Navigate to', 'Enter data', 'Copy', 'Validate', 'Submit', 'Review'];
            
            const workflow = [];
            for (let i = 0; i < size; i++) {
                workflow.push({
                    action: `${actions[i % actions.length]} ${i + 1}`,
                    application: apps[i % apps.length],
                    purpose: `Step ${i + 1} purpose`,
                    visible_in_frames: Array.from({length: Math.floor(Math.random() * 5) + 1}, (_, j) => i * 10 + j),
                    time_formatted: `${Math.floor(Math.random() * 10) + 1}s`
                });
            }
            return workflow;
        }

        function testSimpleWorkflow() {
            const workflow = generateWorkflow(8);
            runTest(workflow, 'simple-metrics', 'Simple 8-Step Workflow');
        }

        function testComplexWorkflow() {
            const workflow = generateWorkflow(30);
            runTest(workflow, 'complex-metrics', 'Complex 30-Step Workflow');
        }

        function testMassiveWorkflow() {
            const workflow = generateWorkflow(100);
            runTest(workflow, 'massive-metrics', 'Massive 100-Step Workflow');
        }

        function runTest(workflow, metricsId, title) {
            const startTotal = performance.now();
            
            // Generate XML with timing
            const result = generator.generateXML(workflow, title);
            
            // Encode for URL
            const startEncode = performance.now();
            const base64 = btoa(unescape(encodeURIComponent(result.xml)));
            const encoded = encodeURIComponent(base64);
            const encodeTime = performance.now() - startEncode;
            
            const url = `https://app.diagrams.net/#U${encoded}`;
            const totalTime = performance.now() - startTotal;
            
            // Display metrics
            const metrics = document.getElementById(metricsId);
            metrics.innerHTML = `
                <div class="${url.length <= 8000 ? 'success' : 'error'}">
                    Steps: ${workflow.length}<br>
                    XML Generation: ${result.timing.total.toFixed(2)}ms<br>
                    - Nodes: ${result.timing.nodes.toFixed(2)}ms<br>
                    - Edges: ${result.timing.edges.toFixed(2)}ms<br>
                    - Wrap: ${result.timing.wrap.toFixed(2)}ms<br>
                    URL Encoding: ${encodeTime.toFixed(2)}ms<br>
                    Total Time: ${totalTime.toFixed(2)}ms<br>
                    XML Size: ${(result.xml.length / 1024).toFixed(1)}KB<br>
                    URL Length: ${url.length} chars (${url.length <= 8000 ? '✅ Safe' : '❌ Too Long'})<br>
                    <br>
                    ${url.length <= 8000 ? 
                        `<button onclick="window.open('${url}', '_blank')">Open in Draw.io</button>` :
                        `<span class="error">URL too long for direct opening. Need to download as file.</span>`
                    }
                </div>
            `;
        }

        function testLayoutScaling() {
            const sizes = [5, 10, 20, 30, 50, 100];
            let html = '<h4>Layout Analysis:</h4>';
            
            sizes.forEach(size => {
                const workflow = generateWorkflow(size);
                const result = generator.generateXML(workflow, `Test ${size} Steps`);
                const layout = generator.calculateSmartLayout(workflow);
                
                html += `
                    <div style="margin: 10px 0;">
                        <strong>${size} steps:</strong><br>
                        - Steps per row: ${layout.layoutInfo.stepsPerRow}<br>
                        - Estimated rows: ${layout.layoutInfo.estimatedRows}<br>
                        - Canvas: ${layout.canvasWidth}x${layout.canvasHeight}px<br>
                    </div>
                `;
            });
            
            document.getElementById('layout-metrics').innerHTML = html;
        }
    </script>
</body>
</html>